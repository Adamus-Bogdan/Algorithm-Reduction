# Algorithm for studying polynomial maps and reductions modulo prime number

In [[1]]() we described an algorithm for inverting polynomial mappings. In [[3]]() complexity of this algorithm was estimated and moreover some aspects of the algorithm's implementation were discussed. Implementation of this algorithm can be found in this repository, in file [`algorithm_abch.py`](https://github.com/Adamus-Bogdan/Algorithm-Reduction/blob/master/algorithm_abch.py). This implementation works for both _Pascal finite_ and not _Pascal finite_ polynomial automorphism. Definition of _Pascal finite_ automorphisms can be found in [[2]]().

In _Algorithm for studying polynomial maps and reductions modulo prime number_ we explore properties of the algorithm, and the class of Pascal finite maps while using Segre homotopy and reductions modulo prime number.  Additionally, in this repository we present our code which illustrates improvements made in the proposed algorithm.

We use fact that calculations performed over finite fields can be more effective (they are faster and use less memory) than those performed over fields of characteristic zero. We proceed as follows.
1. perform reduction modulo some set of prime numbers
2. inverse the reduced mappings using algorithm described in [[1]]()
3. retrieve global inverse using Chinese Reminder Theorem.

One can compare the base method with our improved algorithm. Just clone this repository, you need [SageMath](http://www.sagemath.org/) software. We use the SageMath v9.2 built from sources in WSL Ubuntu (Windows Subsystem for Linux). We additionally installed `tqdm` library. To do that, one need to execute the following command:
```bash
> sage -pip install tqdm 
```
The main file in our project is file [`main.py`](https://github.com/Adamus-Bogdan/Algorithm-Reduction/blob/master/main.py). You need that file to repeat our calculations. This is python program that takes 3 parameters:
- `mapping_name` - the name of mapping you want to inverse. Possibilities are:
    - `EX17` - mapping presented in Example 17 in our paper
    - `EX19` - mapping presented in Example 19 in our paper
    - `EX20` - mapping presented in Example 20 in our paper
- `algorithm_name` - the name of algorithm you want to use to inverse mapping. Possibilities are:
    - `QQ` - use algorithm ABCH which is described in [[1]]()
    - `FF` - use our improved version of ABCH algorithm which is described in _Algorithm for studying polynomial maps and reductions modulo prime number_
    - `GB` - use inversion algorithm based on Groebner basis (for details see below)
    - `GB_MAPLE` - use inversion algorithm based on Groebner basis (for details see below) - maple is used to find Groebner basis only
    - `PARALLEL` - use our improved version of ABCH algorithm which is described in _Algorithm for studying polynomial maps and reductions modulo prime number_ in parallel
- `debug` - optional boolean value stating if you want to see additional output generated by the program during execution (e.g. to track progress), this parameter is `False` by default

## Notation

In this file we assume that `n`-variable polynomial mapping is a list of `n` `n`-variable polynomials:
```
F = (F_1, F_2, ..., F_n)
```
Every such a polynomial is a sum of terms. Every term is product of monomial and coefficient. The every polynomial `F_i` is in the following form:
```
F_i = X_i + H_i
```
Where `H_i` is a zero polynomial or `n`-variable polynomial of lower degree (e.g. vanishing order) at least 2.
We introduce the following notation:
- `d_i` - lower degree of polynomial `H_i`
- `D_i` - degree of polynomial `H_i`
- `D = max D_i`
- `d = min d_i`

The algorithm obtains polynomial mapping
```
G = (G_1, ... G_n)
```
which is list of `n` `n`-variable polynomials.

# Comparison between an original algorithm ABCH and its improved version (using CRT)


Let us compare execution time for ABCH and CRT-ABCH algorithms executed to inverse mapping `EX17`:
```bash
> sage main.py EX17 QQ
Time necessary to inverse mapping: 6782.210833072662
> sage main.py EX17 FF
Time necessary to inverse mapping: 1836.1847116947174
```

# Comparison to Groebner basis based algorithm

We compare our improved algorithm (e.g. containing reductions modulo prime numbers) to algorithm based on Groebner basis described in [[4]]().
Implementation of that algorithm can be found in [`algorithm_gb.py`](https://github.com/Adamus-Bogdan/Algorithm-Reduction/blob/master/algorithm_gb.py).
One can run this algorithm using script [`main.py`](https://github.com/Adamus-Bogdan/Algorithm-Reduction/blob/master/main.py) (as described above).

We compare time of calculating inverse mapping for two mappings using our improved approach and standard Groebner basis method.

Let us compare execution time for all algorithms executed to inverse mappings `EX19`:

```bash
> sage main.py EX19 FF
Time necessary to inverse mapping: 2277.3921859264374
> sage main.py EX19 QQ
Time necessary to inverse mapping: 2726.2071437835693
```
The mapping `EX20`:
```bash
> sage main.py EX20 FF
Time necessary to inverse mapping: 2131.4445753097534
> sage main.py EX20 QQ
Time necessary to inverse mapping: 2669.835104703903
> sage main.py EX20 GB
```

In both cases (example 19 and 20 as well) after 4 hours of execution of Groebner basis based algorithm, we stopped this process.

One can check these results himself. One can also check our paper _Algorithm for studying polynomial maps and reductions modulo prime number_.


# Hardware details

All examples were executed on Windows 10 machine with 16 GB RAM and intel i7 processor.


# Parallel computations


This repo contains first attempt of making the ABCH algorithm parallel. This simple proof of concept proves it is possible, and it really reduces time of execution
```bash
> sage main.py EX19 PARALLEL
Time necessary to inverse mapping: 1435.4873740673065
> sage main.py EX20 PARALLEL
Time necessary to inverse mapping: 1985.2352213859558
```

One can observe that parallel execution allows to reduce execution time.

**Important:** You need to set the following environment variable before computation:
```bash
export SAGE_NUM_THREADS=16
``` 




# Bibliography

1. E. Adamus, P. Bogdan, T. Crespo and Z. Hajto, _An effective study of polynomial maps_, Journal of Algebra and Its Applications, Vol. 16, No. 08, 1750141 (2017)
2. E. Adamus, P. Bogdan, T. Crespo and Z. Hajto, _Pascal finite polynomial automorphisms_, Journal of Algebra and Its Applications, Vol. 18, No. 07, 1950124 (2019)
3. P. Bogdan, _Complexity of the inversion algorithm of polynomial mappings_, Schedae Informaticae, 2016, Volume 25, pages 209–225
4. A. van den Essen, _Polynomial Automorphisms and the Jacobian Conjecture_, Progress in Mathematics, 2000th Edition
5. E.-M. Hubbers. _The Jacobian Conjecture: Cubic homogeneous maps in dimension four_.  Master’s thesis, University of Nijmegen. [URL](http://www.cs.ru.nl/~hubbers/pubs/ivascriptie.pdf). Directed by A. van den Essen.
6. M. Bondt.  _Homogeneous keller maps_. Physical Review Letters, 01 2009.

